This is make.info, produced by makeinfo version 4.2 from make.texi.

INFO-DIR-SECTION GNU Packages
START-INFO-DIR-ENTRY
* Make: (make).            Remake files automatically.
END-INFO-DIR-ENTRY

   This file documents the GNU Make utility, which determines
automatically which pieces of a large program need to be recompiled,
and issues the commands to recompile them.

   This is Edition 0.60, last updated 08 July 2002, of `The GNU Make
Manual', for `make', Version 3.80.

   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled "GNU
Free Documentation License".


File: make.info,  Node: Remaking Makefiles,  Next: Overriding Makefiles,  Prev: Special Variables,  Up: Makefiles

How Makefiles Are Remade
========================

   Sometimes makefiles can be remade from other files, such as RCS or
SCCS files.  If a makefile can be remade from other files, you probably
want `make' to get an up-to-date version of the makefile to read in.

   To this end, after reading in all makefiles, `make' will consider
each as a goal target and attempt to update it.  If a makefile has a
rule which says how to update it (found either in that very makefile or
in another one) or if an implicit rule applies to it (*note Using
Implicit Rules: Implicit Rules.), it will be updated if necessary.
After all makefiles have been checked, if any have actually been
changed, `make' starts with a clean slate and reads all the makefiles
over again.  (It will also attempt to update each of them over again,
but normally this will not change them again, since they are already up
to date.)

   If you know that one or more of your makefiles cannot be remade and
you want to keep `make' from performing an implicit rule search on
them, perhaps for efficiency reasons, you can use any normal method of
preventing implicit rule lookup to do so.  For example, you can write an
explicit rule with the makefile as the target, and an empty command
string (*note Using Empty Commands: Empty Commands.).

   If the makefiles specify a double-colon rule to remake a file with
commands but no prerequisites, that file will always be remade (*note
Double-Colon::).  In the case of makefiles, a makefile that has a
double-colon rule with commands but no prerequisites will be remade
every time `make' is run, and then again after `make' starts over and
reads the makefiles in again.  This would cause an infinite loop:
`make' would constantly remake the makefile, and never do anything
else.  So, to avoid this, `make' will *not* attempt to remake makefiles
which are specified as targets of a double-colon rule with commands but
no prerequisites.

   If you do not specify any makefiles to be read with `-f' or `--file'
options, `make' will try the default makefile names; *note What Name to
Give Your Makefile: Makefile Names..  Unlike makefiles explicitly
requested with `-f' or `--file' options, `make' is not certain that
these makefiles should exist.  However, if a default makefile does not
exist but can be created by running `make' rules, you probably want the
rules to be run so that the makefile can be used.

   Therefore, if none of the default makefiles exists, `make' will try
to make each of them in the same order in which they are searched for
(*note What Name to Give Your Makefile: Makefile Names.)  until it
succeeds in making one, or it runs out of names to try.  Note that it
is not an error if `make' cannot find or make any makefile; a makefile
is not always necessary.

   When you use the `-t' or `--touch' option (*note Instead of
Executing the Commands: Instead of Execution.), you would not want to
use an out-of-date makefile to decide which targets to touch.  So the
`-t' option has no effect on updating makefiles; they are really
updated even if `-t' is specified.  Likewise, `-q' (or `--question')
and `-n' (or `--just-print') do not prevent updating of makefiles,
because an out-of-date makefile would result in the wrong output for
other targets.  Thus, `make -f mfile -n foo' will update `mfile', read
it in, and then print the commands to update `foo' and its prerequisites
without running them.  The commands printed for `foo' will be those
specified in the updated contents of `mfile'.

   However, on occasion you might actually wish to prevent updating of
even the makefiles.  You can do this by specifying the makefiles as
goals in the command line as well as specifying them as makefiles.
When the makefile name is specified explicitly as a goal, the options
`-t' and so on do apply to them.

   Thus, `make -f mfile -n mfile foo' would read the makefile `mfile',
print the commands needed to update it without actually running them,
and then print the commands needed to update `foo' without running
them.  The commands for `foo' will be those specified by the existing
contents of `mfile'.


File: make.info,  Node: Overriding Makefiles,  Next: Reading Makefiles,  Prev: Remaking Makefiles,  Up: Makefiles

Overriding Part of Another Makefile
===================================

   Sometimes it is useful to have a makefile that is mostly just like
another makefile.  You can often use the `include' directive to include
one in the other, and add more targets or variable definitions.
However, if the two makefiles give different commands for the same
target, `make' will not let you just do this.  But there is another way.

   In the containing makefile (the one that wants to include the other),
you can use a match-anything pattern rule to say that to remake any
target that cannot be made from the information in the containing
makefile, `make' should look in another makefile.  *Note Pattern
Rules::, for more information on pattern rules.

   For example, if you have a makefile called `Makefile' that says how
to make the target `foo' (and other targets), you can write a makefile
called `GNUmakefile' that contains:

     foo:
             frobnicate > foo
     
     %: force
             @$(MAKE) -f Makefile $@
     force: ;

   If you say `make foo', `make' will find `GNUmakefile', read it, and
see that to make `foo', it needs to run the command `frobnicate > foo'.
If you say `make bar', `make' will find no way to make `bar' in
`GNUmakefile', so it will use the commands from the pattern rule: `make
-f Makefile bar'.  If `Makefile' provides a rule for updating `bar',
`make' will apply the rule.  And likewise for any other target that
`GNUmakefile' does not say how to make.

   The way this works is that the pattern rule has a pattern of just
`%', so it matches any target whatever.  The rule specifies a
prerequisite `force', to guarantee that the commands will be run even
if the target file already exists.  We give `force' target empty
commands to prevent `make' from searching for an implicit rule to build
it--otherwise it would apply the same match-anything rule to `force'
itself and create a prerequisite loop!


File: make.info,  Node: Reading Makefiles,  Prev: Overriding Makefiles,  Up: Makefiles

How `make' Reads a Makefile
===========================

   GNU `make' does its work in two distinct phases.  During the first
phase it reads all the makefiles, included makefiles, etc. and
internalizes all the variables and their values, implicit and explicit
rules, and constructs a dependency graph of all the targets and their
prerequisites.  During the second phase, `make' uses these internal
structures to determine what targets will need to be rebuilt and to
invoke the rules necessary to do so.

   It's important to understand this two-phase approach because it has a
direct impact on how variable and function expansion happens; this is
often a source of some confusion when writing makefiles.  Here we will
present a summary of the phases in which expansion happens for different
constructs within the makefile.  We say that expansion is "immediate"
if it happens during the first phase: in this case `make' will expand
any variables or functions in that section of a construct as the
makefile is parsed.  We say that expansion is "deferred" if expansion
is not performed immediately.  Expansion of deferred construct is not
performed until either the construct appears later in an immediate
context, or until the second phase.

   You may not be familiar with some of these constructs yet.  You can
reference this section as you become familiar with them, in later
chapters.

Variable Assignment
-------------------

   Variable definitions are parsed as follows:

     IMMEDIATE = DEFERRED
     IMMEDIATE ?= DEFERRED
     IMMEDIATE := IMMEDIATE
     IMMEDIATE += DEFERRED or IMMEDIATE
     
     define IMMEDIATE
       DEFERRED
     endef

   For the append operator, `+=', the right-hand side is considered
immediate if the variable was previously set as a simple variable
(`:='), and deferred otherwise.

Conditional Statements
----------------------

   All instances of conditional syntax are parsed immediately, in their
entirety; this includes the `ifdef', `ifeq', `ifndef', and `ifneq'
forms.

Rule Definition
---------------

   A rule is always expanded the same way, regardless of the form:

     IMMEDIATE : IMMEDIATE ; DEFERRED
     	DEFERRED

   That is, the target and prerequisite sections are expanded
immediately, and the commands used to construct the target are always
deferred.  This general rule is true for explicit rules, pattern rules,
suffix rules, static pattern rules, and simple prerequisite definitions.


File: make.info,  Node: Rules,  Next: Commands,  Prev: Makefiles,  Up: Top

Writing Rules
*************

   A "rule" appears in the makefile and says when and how to remake
certain files, called the rule's "targets" (most often only one per
rule).  It lists the other files that are the "prerequisites" of the
target, and "commands" to use to create or update the target.

   The order of rules is not significant, except for determining the
"default goal": the target for `make' to consider, if you do not
otherwise specify one.  The default goal is the target of the first
rule in the first makefile.  If the first rule has multiple targets,
only the first target is taken as the default.  There are two
exceptions: a target starting with a period is not a default unless it
contains one or more slashes, `/', as well; and, a target that defines
a pattern rule has no effect on the default goal.  (*Note Defining and
Redefining Pattern Rules: Pattern Rules.)

   Therefore, we usually write the makefile so that the first rule is
the one for compiling the entire program or all the programs described
by the makefile (often with a target called `all').  *Note Arguments to
Specify the Goals: Goals.

* Menu:

* Rule Example::                An example explained.
* Rule Syntax::                 General syntax explained.
* Prerequisite Types::          There are two types of prerequisites.
* Wildcards::                   Using wildcard characters such as `*'.
* Directory Search::            Searching other directories for source files.
* Phony Targets::               Using a target that is not a real file's name.
* Force Targets::               You can use a target without commands
                                  or prerequisites to mark other
                                  targets as phony.
* Empty Targets::               When only the date matters and the
                                  files are empty.
* Special Targets::             Targets with special built-in meanings.
* Multiple Targets::            When to make use of several targets in a rule.
* Multiple Rules::              How to use several rules with the same target.
* Static Pattern::              Static pattern rules apply to multiple targets
                                  and can vary the prerequisites according to
                                  the target name.
* Double-Colon::                How to use a special kind of rule to allow
                                  several independent rules for one target.
* Automatic Prerequisites::     How to automatically generate rules giving
                                  prerequisites from source files themselves.


File: make.info,  Node: Rule Example,  Next: Rule Syntax,  Prev: Rules,  Up: Rules

Rule Example
============

   Here is an example of a rule:

     foo.o : foo.c defs.h       # module for twiddling the frobs
             cc -c -g foo.c

   Its target is `foo.o' and its prerequisites are `foo.c' and
`defs.h'.  It has one command, which is `cc -c -g foo.c'.  The command
line starts with a tab to identify it as a command.

   This rule says two things:

   * How to decide whether `foo.o' is out of date: it is out of date if
     it does not exist, or if either `foo.c' or `defs.h' is more recent
     than it.

   * How to update the file `foo.o': by running `cc' as stated.  The
     command does not explicitly mention `defs.h', but we presume that
     `foo.c' includes it, and that that is why `defs.h' was added to
     the prerequisites.


File: make.info,  Node: Rule Syntax,  Next: Prerequisite Types,  Prev: Rule Example,  Up: Rules

Rule Syntax
===========

   In general, a rule looks like this:

     TARGETS : PREREQUISITES
             COMMAND
             ...

or like this:

     TARGETS : PREREQUISITES ; COMMAND
             COMMAND
             ...

   The TARGETS are file names, separated by spaces.  Wildcard
characters may be used (*note Using Wildcard Characters in File Names:
Wildcards.) and a name of the form `A(M)' represents member M in
archive file A (*note Archive Members as Targets: Archive Members.).
Usually there is only one target per rule, but occasionally there is a
reason to have more (*note Multiple Targets in a Rule: Multiple
Targets.).

   The COMMAND lines start with a tab character.  The first command may
appear on the line after the prerequisites, with a tab character, or may
appear on the same line, with a semicolon.  Either way, the effect is
the same.  *Note Writing the Commands in Rules: Commands.

   Because dollar signs are used to start variable references, if you
really want a dollar sign in a rule you must write two of them, `$$'
(*note How to Use Variables: Using Variables.).  You may split a long
line by inserting a backslash followed by a newline, but this is not
required, as `make' places no limit on the length of a line in a
makefile.

   A rule tells `make' two things: when the targets are out of date,
and how to update them when necessary.

   The criterion for being out of date is specified in terms of the
PREREQUISITES, which consist of file names separated by spaces.
(Wildcards and archive members (*note Archives::) are allowed here too.)
A target is out of date if it does not exist or if it is older than any
of the prerequisites (by comparison of last-modification times).  The
idea is that the contents of the target file are computed based on
information in the prerequisites, so if any of the prerequisites
changes, the contents of the existing target file are no longer
necessarily valid.

   How to update is specified by COMMANDS.  These are lines to be
executed by the shell (normally `sh'), but with some extra features
(*note Writing the Commands in Rules: Commands.).


File: make.info,  Node: Prerequisite Types,  Next: Wildcards,  Prev: Rule Syntax,  Up: Rules

Types of Prerequisites
======================

   There are actually two different types of prerequisites understood by
GNU `make': normal prerequisites such as described in the previous
section, and "order-only" prerequisites.  A normal prerequisite
actually makes two statements: first, it imposes an order of execution
of build commands: any commands necessary to build any of a target's
prerequisites will be fully executed before any commands necessary to
build the target.  Second, it imposes a dependency relationship: if any
prerequisite is newer than the target, then the target is considered
out-of-date and must be rebuilt.

   Normally, this is exactly what you want: if a target's prerequisite
is updated, then the target should also be updated.

   Occasionally, however, you have a situation where you want to impose
a specific ordering on the rules to be invoked _without_ forcing the
target to be updated if one of those rules is executed.  In that case,
you want to define "order-only" prerequisites.  Order-only
prerequisites can be specified by placing a pipe symbol (`|') in the
prerequisites list: any prerequisites to the left of the pipe symbol
are normal; any prerequisites to the right are order-only:

     TARGETS : NORMAL-PREREQUISITES | ORDER-ONLY-PREREQUISITES

   The normal prerequisites section may of course be empty.  Also, you
may still declare multiple lines of prerequisites for the same target:
they are appended appropriately.  Note that if you declare the same
file to be both a normal and an order-only prerequisite, the normal
prerequisite takes precedence (since they are a strict superset of the
behavior of an order-only prerequisite).


File: make.info,  Node: Wildcards,  Next: Directory Search,  Prev: Prerequisite Types,  Up: Rules

Using Wildcard Characters in File Names
=======================================

   A single file name can specify many files using "wildcard
characters".  The wildcard characters in `make' are `*', `?' and
`[...]', the same as in the Bourne shell.  For example, `*.c' specifies
a list of all the files (in the working directory) whose names end in
`.c'.

   The character `~' at the beginning of a file name also has special
significance.  If alone, or followed by a slash, it represents your home
directory.  For example `~/bin' expands to `/home/you/bin'.  If the `~'
is followed by a word, the string represents the home directory of the
user named by that word.  For example `~john/bin' expands to
`/home/john/bin'.  On systems which don't have a home directory for
each user (such as MS-DOS or MS-Windows), this functionality can be
simulated by setting the environment variable HOME.

   Wildcard expansion happens automatically in targets, in
prerequisites, and in commands (where the shell does the expansion).
In other contexts, wildcard expansion happens only if you request it
explicitly with the `wildcard' function.

   The special significance of a wildcard character can be turned off by
preceding it with a backslash.  Thus, `foo\*bar' would refer to a
specific file whose name consists of `foo', an asterisk, and `bar'.

* Menu:

* Wildcard Examples::           Several examples
* Wildcard Pitfall::            Problems to avoid.
* Wildcard Function::           How to cause wildcard expansion where
                                  it does not normally take place.


File: make.info,  Node: Wildcard Examples,  Next: Wildcard Pitfall,  Prev: Wildcards,  Up: Wildcards

Wildcard Examples
-----------------

   Wildcards can be used in the commands of a rule, where they are
expanded by the shell.  For example, here is a rule to delete all the
object files:

     clean:
             rm -f *.o

   Wildcards are also useful in the prerequisites of a rule.  With the
following rule in the makefile, `make print' will print all the `.c'
files that have changed since the last time you printed them:

     print: *.c
             lpr -p $?
             touch print

This rule uses `print' as an empty target file; see *Note Empty Target
Files to Record Events: Empty Targets.  (The automatic variable `$?' is
used to print only those files that have changed; see *Note Automatic
Variables: Automatic.)

   Wildcard expansion does not happen when you define a variable.
Thus, if you write this:

     objects = *.o

then the value of the variable `objects' is the actual string `*.o'.
However, if you use the value of `objects' in a target, prerequisite or
command, wildcard expansion will take place at that time.  To set
`objects' to the expansion, instead use:

     objects := $(wildcard *.o)

*Note Wildcard Function::.


File: make.info,  Node: Wildcard Pitfall,  Next: Wildcard Function,  Prev: Wildcard Examples,  Up: Wildcards

Pitfalls of Using Wildcards
---------------------------

   Now here is an example of a naive way of using wildcard expansion,
that does not do what you would intend.  Suppose you would like to say
that the executable file `foo' is made from all the object files in the
directory, and you write this:

     objects = *.o
     
     foo : $(objects)
             cc -o foo $(CFLAGS) $(objects)

The value of `objects' is the actual string `*.o'.  Wildcard expansion
happens in the rule for `foo', so that each _existing_ `.o' file
becomes a prerequisite of `foo' and will be recompiled if necessary.

   But what if you delete all the `.o' files?  When a wildcard matches
no files, it is left as it is, so then `foo' will depend on the
oddly-named file `*.o'.  Since no such file is likely to exist, `make'
will give you an error saying it cannot figure out how to make `*.o'.
This is not what you want!

   Actually it is possible to obtain the desired result with wildcard
expansion, but you need more sophisticated techniques, including the
`wildcard' function and string substitution.  *Note The Function
`wildcard': Wildcard Function.

   Microsoft operating systems (MS-DOS and MS-Windows) use backslashes
to separate directories in pathnames, like so:

       c:\foo\bar\baz.c

   This is equivalent to the Unix-style `c:/foo/bar/baz.c' (the `c:'
part is the so-called drive letter).  When `make' runs on these
systems, it supports backslashes as well as the Unix-style forward
slashes in pathnames.  However, this support does _not_ include the
wildcard expansion, where backslash is a quote character.  Therefore,
you _must_ use Unix-style slashes in these cases.


File: make.info,  Node: Wildcard Function,  Prev: Wildcard Pitfall,  Up: Wildcards

The Function `wildcard'
-----------------------

   Wildcard expansion happens automatically in rules.  But wildcard
expansion does not normally take place when a variable is set, or
inside the arguments of a function.  If you want to do wildcard
expansion in such places, you need to use the `wildcard' function, like
this:

     $(wildcard PATTERN...)

This string, used anywhere in a makefile, is replaced by a
space-separated list of names of existing files that match one of the
given file name patterns.  If no existing file name matches a pattern,
then that pattern is omitted from the output of the `wildcard'
function.  Note that this is different from how unmatched wildcards
behave in rules, where they are used verbatim rather than ignored
(*note Wildcard Pitfall::).

   One use of the `wildcard' function is to get a list of all the C
source files in a directory, like this:

     $(wildcard *.c)

   We can change the list of C source files into a list of object files
by replacing the `.c' suffix with `.o' in the result, like this:

     $(patsubst %.c,%.o,$(wildcard *.c))

(Here we have used another function, `patsubst'.  *Note Functions for
String Substitution and Analysis: Text Functions.)

   Thus, a makefile to compile all C source files in the directory and
then link them together could be written as follows:

     objects := $(patsubst %.c,%.o,$(wildcard *.c))
     
     foo : $(objects)
             cc -o foo $(objects)

(This takes advantage of the implicit rule for compiling C programs, so
there is no need to write explicit rules for compiling the files.
*Note The Two Flavors of Variables: Flavors, for an explanation of
`:=', which is a variant of `='.)


File: make.info,  Node: Directory Search,  Next: Phony Targets,  Prev: Wildcards,  Up: Rules

Searching Directories for Prerequisites
=======================================

   For large systems, it is often desirable to put sources in a separate
directory from the binaries.  The "directory search" features of `make'
facilitate this by searching several directories automatically to find
a prerequisite.  When you redistribute the files among directories, you
do not need to change the individual rules, just the search paths.

* Menu:

* General Search::              Specifying a search path that applies
                                  to every prerequisite.
* Selective Search::            Specifying a search path
                                  for a specified class of names.
* Search Algorithm::            When and how search paths are applied.
* Commands/Search::             How to write shell commands that work together
                                  with search paths.
* Implicit/Search::             How search paths affect implicit rules.
* Libraries/Search::            Directory search for link libraries.


File: make.info,  Node: General Search,  Next: Selective Search,  Prev: Directory Search,  Up: Directory Search

`VPATH': Search Path for All Prerequisites
------------------------------------------

   The value of the `make' variable `VPATH' specifies a list of
directories that `make' should search.  Most often, the directories are
expected to contain prerequisite files that are not in the current
directory; however, `VPATH' specifies a search list that `make' applies
for all files, including files which are targets of rules.

   Thus, if a file that is listed as a target or prerequisite does not
exist in the current directory, `make' searches the directories listed
in `VPATH' for a file with that name.  If a file is found in one of
them, that file may become the prerequisite (see below).  Rules may then
specify the names of files in the prerequisite list as if they all
existed in the current directory.  *Note Writing Shell Commands with
Directory Search: Commands/Search.

   In the `VPATH' variable, directory names are separated by colons or
blanks.  The order in which directories are listed is the order followed
by `make' in its search.  (On MS-DOS and MS-Windows, semi-colons are
used as separators of directory names in `VPATH', since the colon can
be used in the pathname itself, after the drive letter.)

   For example,

     VPATH = src:../headers

specifies a path containing two directories, `src' and `../headers',
which `make' searches in that order.

   With this value of `VPATH', the following rule,

     foo.o : foo.c

is interpreted as if it were written like this:

     foo.o : src/foo.c

assuming the file `foo.c' does not exist in the current directory but
is found in the directory `src'.


File: make.info,  Node: Selective Search,  Next: Search Algorithm,  Prev: General Search,  Up: Directory Search

The `vpath' Directive
---------------------

   Similar to the `VPATH' variable, but more selective, is the `vpath'
directive (note lower case), which allows you to specify a search path
for a particular class of file names: those that match a particular
pattern.  Thus you can supply certain search directories for one class
of file names and other directories (or none) for other file names.

   There are three forms of the `vpath' directive:

`vpath PATTERN DIRECTORIES'
     Specify the search path DIRECTORIES for file names that match
     PATTERN.

     The search path, DIRECTORIES, is a list of directories to be
     searched, separated by colons (semi-colons on MS-DOS and
     MS-Windows) or blanks, just like the search path used in the
     `VPATH' variable.

`vpath PATTERN'
     Clear out the search path associated with PATTERN.

`vpath'
     Clear all search paths previously specified with `vpath'
     directives.

   A `vpath' pattern is a string containing a `%' character.  The
string must match the file name of a prerequisite that is being searched
for, the `%' character matching any sequence of zero or more characters
(as in pattern rules; *note Defining and Redefining Pattern Rules:
Pattern Rules.).  For example, `%.h' matches files that end in `.h'.
(If there is no `%', the pattern must match the prerequisite exactly,
which is not useful very often.)

   `%' characters in a `vpath' directive's pattern can be quoted with
preceding backslashes (`\').  Backslashes that would otherwise quote
`%' characters can be quoted with more backslashes.  Backslashes that
quote `%' characters or other backslashes are removed from the pattern
before it is compared to file names.  Backslashes that are not in
danger of quoting `%' characters go unmolested.

   When a prerequisite fails to exist in the current directory, if the
PATTERN in a `vpath' directive matches the name of the prerequisite
file, then the DIRECTORIES in that directive are searched just like
(and before) the directories in the `VPATH' variable.

   For example,

     vpath %.h ../headers

tells `make' to look for any prerequisite whose name ends in `.h' in
the directory `../headers' if the file is not found in the current
directory.

   If several `vpath' patterns match the prerequisite file's name, then
`make' processes each matching `vpath' directive one by one, searching
all the directories mentioned in each directive.  `make' handles
multiple `vpath' directives in the order in which they appear in the
makefile; multiple directives with the same pattern are independent of
each other.

   Thus,

     vpath %.c foo
     vpath %   blish
     vpath %.c bar

will look for a file ending in `.c' in `foo', then `blish', then `bar',
while

     vpath %.c foo:bar
     vpath %   blish

will look for a file ending in `.c' in `foo', then `bar', then `blish'.


File: make.info,  Node: Search Algorithm,  Next: Commands/Search,  Prev: Selective Search,  Up: Directory Search

How Directory Searches are Performed
------------------------------------

   When a prerequisite is found through directory search, regardless of
type (general or selective), the pathname located may not be the one
that `make' actually provides you in the prerequisite list.  Sometimes
the path discovered through directory search is thrown away.

   The algorithm `make' uses to decide whether to keep or abandon a
path found via directory search is as follows:

  1. If a target file does not exist at the path specified in the
     makefile, directory search is performed.

  2. If the directory search is successful, that path is kept and this
     file is tentatively stored as the target.

  3. All prerequisites of this target are examined using this same
     method.

  4. After processing the prerequisites, the target may or may not need
     to be rebuilt:

       a. If the target does _not_ need to be rebuilt, the path to the
          file found during directory search is used for any
          prerequisite lists which contain this target.  In short, if
          `make' doesn't need to rebuild the target then you use the
          path found via directory search.

       b. If the target _does_ need to be rebuilt (is out-of-date), the
          pathname found during directory search is _thrown away_, and
          the target is rebuilt using the file name specified in the
          makefile.  In short, if `make' must rebuild, then the target
          is rebuilt locally, not in the directory found via directory
          search.

   This algorithm may seem complex, but in practice it is quite often
exactly what you want.

   Other versions of `make' use a simpler algorithm: if the file does
not exist, and it is found via directory search, then that pathname is
always used whether or not the target needs to be built.  Thus, if the
target is rebuilt it is created at the pathname discovered during
directory search.

   If, in fact, this is the behavior you want for some or all of your
directories, you can use the `GPATH' variable to indicate this to
`make'.

   `GPATH' has the same syntax and format as `VPATH' (that is, a space-
or colon-delimited list of pathnames).  If an out-of-date target is
found by directory search in a directory that also appears in `GPATH',
then that pathname is not thrown away.  The target is rebuilt using the
expanded path.


File: make.info,  Node: Commands/Search,  Next: Implicit/Search,  Prev: Search Algorithm,  Up: Directory Search

Writing Shell Commands with Directory Search
--------------------------------------------

   When a prerequisite is found in another directory through directory
search, this cannot change the commands of the rule; they will execute
as written.  Therefore, you must write the commands with care so that
they will look for the prerequisite in the directory where `make' finds
it.

   This is done with the "automatic variables" such as `$^' (*note
Automatic Variables: Automatic.).  For instance, the value of `$^' is a
list of all the prerequisites of the rule, including the names of the
directories in which they were found, and the value of `$@' is the
target.  Thus:

     foo.o : foo.c
             cc -c $(CFLAGS) $^ -o $@

(The variable `CFLAGS' exists so you can specify flags for C
compilation by implicit rules; we use it here for consistency so it will
affect all C compilations uniformly; *note Variables Used by Implicit
Rules: Implicit Variables..)

   Often the prerequisites include header files as well, which you do
not want to mention in the commands.  The automatic variable `$<' is
just the first prerequisite:

     VPATH = src:../headers
     foo.o : foo.c defs.h hack.h
             cc -c $(CFLAGS) $< -o $@


File: make.info,  Node: Implicit/Search,  Next: Libraries/Search,  Prev: Commands/Search,  Up: Directory Search

Directory Search and Implicit Rules
-----------------------------------

   The search through the directories specified in `VPATH' or with
`vpath' also happens during consideration of implicit rules (*note
Using Implicit Rules: Implicit Rules.).

   For example, when a file `foo.o' has no explicit rule, `make'
considers implicit rules, such as the built-in rule to compile `foo.c'
if that file exists.  If such a file is lacking in the current
directory, the appropriate directories are searched for it.  If `foo.c'
exists (or is mentioned in the makefile) in any of the directories, the
implicit rule for C compilation is applied.

   The commands of implicit rules normally use automatic variables as a
matter of necessity; consequently they will use the file names found by
directory search with no extra effort.


File: make.info,  Node: Libraries/Search,  Prev: Implicit/Search,  Up: Directory Search

Directory Search for Link Libraries
-----------------------------------

   Directory search applies in a special way to libraries used with the
linker.  This special feature comes into play when you write a
prerequisite whose name is of the form `-lNAME'.  (You can tell
something strange is going on here because the prerequisite is normally
the name of a file, and the _file name_ of a library generally looks
like `libNAME.a', not like `-lNAME'.)

   When a prerequisite's name has the form `-lNAME', `make' handles it
specially by searching for the file `libNAME.so' in the current
directory, in directories specified by matching `vpath' search paths
and the `VPATH' search path, and then in the directories `/lib',
`/usr/lib', and `PREFIX/lib' (normally `/usr/local/lib', but
MS-DOS/MS-Windows versions of `make' behave as if PREFIX is defined to
be the root of the DJGPP installation tree).

   If that file is not found, then the file `libNAME.a' is searched
for, in the same directories as above.

   For example, if there is a `/usr/lib/libcurses.a' library on your
system (and no `/usr/lib/libcurses.so' file), then

     foo : foo.c -lcurses
             cc $^ -o $@

would cause the command `cc foo.c /usr/lib/libcurses.a -o foo' to be
executed when `foo' is older than `foo.c' or than
`/usr/lib/libcurses.a'.

   Although the default set of files to be searched for is `libNAME.so'
and `libNAME.a', this is customizable via the `.LIBPATTERNS' variable.
Each word in the value of this variable is a pattern string.  When a
prerequisite like `-lNAME' is seen, `make' will replace the percent in
each pattern in the list with NAME and perform the above directory
searches using that library filename.  If no library is found, the next
word in the list will be used.

   The default value for `.LIBPATTERNS' is "`lib%.so lib%.a'", which
provides the default behavior described above.

   You can turn off link library expansion completely by setting this
variable to an empty value.


File: make.info,  Node: Phony Targets,  Next: Force Targets,  Prev: Directory Search,  Up: Rules

Phony Targets
=============

   A phony target is one that is not really the name of a file.  It is
just a name for some commands to be executed when you make an explicit
request.  There are two reasons to use a phony target: to avoid a
conflict with a file of the same name, and to improve performance.

   If you write a rule whose commands will not create the target file,
the commands will be executed every time the target comes up for
remaking.  Here is an example:

     clean:
             rm *.o temp

Because the `rm' command does not create a file named `clean', probably
no such file will ever exist.  Therefore, the `rm' command will be
executed every time you say `make clean'.

   The phony target will cease to work if anything ever does create a
file named `clean' in this directory.  Since it has no prerequisites,
the file `clean' would inevitably be considered up to date, and its
commands would not be executed.  To avoid this problem, you can
explicitly declare the target to be phony, using the special target
`.PHONY' (*note Special Built-in Target Names: Special Targets.) as
follows:

     .PHONY : clean

Once this is done, `make clean' will run the commands regardless of
whether there is a file named `clean'.

   Since it knows that phony targets do not name actual files that
could be remade from other files, `make' skips the implicit rule search
for phony targets (*note Implicit Rules::).  This is why declaring a
target phony is good for performance, even if you are not worried about
the actual file existing.

   Thus, you first write the line that states that `clean' is a phony
target, then you write the rule, like this:

     .PHONY: clean
     clean:
             rm *.o temp

   Another example of the usefulness of phony targets is in conjunction
with recursive invocations of `make' (for more information, see *Note
Recursive Use of `make': Recursion).  In this case the makefile will
often contain a variable which lists a number of subdirectories to be
built.  One way to handle this is with one rule whose command is a
shell loop over the subdirectories, like this:

     SUBDIRS = foo bar baz
     
     subdirs:
             for dir in $(SUBDIRS); do \
               $(MAKE) -C $$dir; \
             done

   There are a few problems with this method, however.  First, any error
detected in a submake is not noted by this rule, so it will continue to
build the rest of the directories even when one fails.  This can be
overcome by adding shell commands to note the error and exit, but then
it will do so even if `make' is invoked with the `-k' option, which is
unfortunate.  Second, and perhaps more importantly, you cannot take
advantage of the parallel build capabilities of make using this method,
since there is only one rule.

   By declaring the subdirectories as phony targets (you must do this as
the subdirectory obviously always exists; otherwise it won't be built)
you can remove these problems:

     SUBDIRS = foo bar baz
     
     .PHONY: subdirs $(SUBDIRS)
     
     subdirs: $(SUBDIRS)
     
     $(SUBDIRS):
             $(MAKE) -C $@
     
     foo: baz

   Here we've also declared that the `foo' subdirectory cannot be built
until after the `baz' subdirectory is complete; this kind of
relationship declaration is particularly important when attempting
parallel builds.

   A phony target should not be a prerequisite of a real target file;
if it is, its commands are run every time `make' goes to update that
file.  As long as a phony target is never a prerequisite of a real
target, the phony target commands will be executed only when the phony
target is a specified goal (*note Arguments to Specify the Goals:
Goals.).

   Phony targets can have prerequisites.  When one directory contains
multiple programs, it is most convenient to describe all of the
programs in one makefile `./Makefile'.  Since the target remade by
default will be the first one in the makefile, it is common to make
this a phony target named `all' and give it, as prerequisites, all the
individual programs.  For example:

     all : prog1 prog2 prog3
     .PHONY : all
     
     prog1 : prog1.o utils.o
             cc -o prog1 prog1.o utils.o
     
     prog2 : prog2.o
             cc -o prog2 prog2.o
     
     prog3 : prog3.o sort.o utils.o
             cc -o prog3 prog3.o sort.o utils.o

Now you can say just `make' to remake all three programs, or specify as
arguments the ones to remake (as in `make prog1 prog3').

   When one phony target is a prerequisite of another, it serves as a
subroutine of the other.  For example, here `make cleanall' will delete
the object files, the difference files, and the file `program':

     .PHONY: cleanall cleanobj cleandiff
     
     cleanall : cleanobj cleandiff
             rm program
     
     cleanobj :
             rm *.o
     
     cleandiff :
             rm *.diff


File: make.info,  Node: Force Targets,  Next: Empty Targets,  Prev: Phony Targets,  Up: Rules

Rules without Commands or Prerequisites
=======================================

   If a rule has no prerequisites or commands, and the target of the
rule is a nonexistent file, then `make' imagines this target to have
been updated whenever its rule is run.  This implies that all targets
depending on this one will always have their commands run.

   An example will illustrate this:

     clean: FORCE
             rm $(objects)
     FORCE:

   Here the target `FORCE' satisfies the special conditions, so the
target `clean' that depends on it is forced to run its commands.  There
is nothing special about the name `FORCE', but that is one name
commonly used this way.

   As you can see, using `FORCE' this way has the same results as using
`.PHONY: clean'.

   Using `.PHONY' is more explicit and more efficient.  However, other
versions of `make' do not support `.PHONY'; thus `FORCE' appears in
many makefiles.  *Note Phony Targets::.


File: make.info,  Node: Empty Targets,  Next: Special Targets,  Prev: Force Targets,  Up: Rules

Empty Target Files to Record Events
===================================

   The "empty target" is a variant of the phony target; it is used to
hold commands for an action that you request explicitly from time to
time.  Unlike a phony target, this target file can really exist; but
the file's contents do not matter, and usually are empty.

   The purpose of the empty target file is to record, with its
last-modification time, when the rule's commands were last executed.  It
does so because one of the commands is a `touch' command to update the
target file.

   The empty target file should have some prerequisites (otherwise it
doesn't make sense).  When you ask to remake the empty target, the
commands are executed if any prerequisite is more recent than the
target; in other words, if a prerequisite has changed since the last
time you remade the target.  Here is an example:

     print: foo.c bar.c
             lpr -p $?
             touch print

With this rule, `make print' will execute the `lpr' command if either
source file has changed since the last `make print'.  The automatic
variable `$?' is used to print only those files that have changed
(*note Automatic Variables: Automatic.).


File: make.info,  Node: Special Targets,  Next: Multiple Targets,  Prev: Empty Targets,  Up: Rules

Special Built-in Target Names
=============================

   Certain names have special meanings if they appear as targets.

`.PHONY'
     The prerequisites of the special target `.PHONY' are considered to
     be phony targets.  When it is time to consider such a target,
     `make' will run its commands unconditionally, regardless of
     whether a file with that name exists or what its last-modification
     time is.  *Note Phony Targets: Phony Targets.

`.SUFFIXES'
     The prerequisites of the special target `.SUFFIXES' are the list
     of suffixes to be used in checking for suffix rules.  *Note
     Old-Fashioned Suffix Rules: Suffix Rules.

`.DEFAULT'
     The commands specified for `.DEFAULT' are used for any target for
     which no rules are found (either explicit rules or implicit rules).
     *Note Last Resort::.  If `.DEFAULT' commands are specified, every
     file mentioned as a prerequisite, but not as a target in a rule,
     will have these commands executed on its behalf.  *Note Implicit
     Rule Search Algorithm: Implicit Rule Search.

`.PRECIOUS'
     The targets which `.PRECIOUS' depends on are given the following
     special treatment: if `make' is killed or interrupted during the
     execution of their commands, the target is not deleted.  *Note
     Interrupting or Killing `make': Interrupts.  Also, if the target
     is an intermediate file, it will not be deleted after it is no
     longer needed, as is normally done.  *Note Chains of Implicit
     Rules: Chained Rules.  In this latter respect it overlaps with the
     `.SECONDARY' special target.

     You can also list the target pattern of an implicit rule (such as
     `%.o') as a prerequisite file of the special target `.PRECIOUS' to
     preserve intermediate files created by rules whose target patterns
     match that file's name.

`.INTERMEDIATE'
     The targets which `.INTERMEDIATE' depends on are treated as
     intermediate files.  *Note Chains of Implicit Rules: Chained Rules.
     `.INTERMEDIATE' with no prerequisites has no effect.

`.SECONDARY'
     The targets which `.SECONDARY' depends on are treated as
     intermediate files, except that they are never automatically
     deleted.  *Note Chains of Implicit Rules: Chained Rules.

     `.SECONDARY' with no prerequisites causes all targets to be treated
     as secondary (i.e., no target is removed because it is considered
     intermediate).

`.DELETE_ON_ERROR'
     If `.DELETE_ON_ERROR' is mentioned as a target anywhere in the
     makefile, then `make' will delete the target of a rule if it has
     changed and its commands exit with a nonzero exit status, just as
     it does when it receives a signal.  *Note Errors in Commands:
     Errors.

`.IGNORE'
     If you specify prerequisites for `.IGNORE', then `make' will
     ignore errors in execution of the commands run for those particular
     files.  The commands for `.IGNORE' are not meaningful.

     If mentioned as a target with no prerequisites, `.IGNORE' says to
     ignore errors in execution of commands for all files.  This usage
     of `.IGNORE' is supported only for historical compatibility.  Since
     this affects every command in the makefile, it is not very useful;
     we recommend you use the more selective ways to ignore errors in
     specific commands.  *Note Errors in Commands: Errors.

`.LOW_RESOLUTION_TIME'
     If you specify prerequisites for `.LOW_RESOLUTION_TIME', `make'
     assumes that these files are created by commands that generate low
     resolution time stamps.  The commands for `.LOW_RESOLUTION_TIME'
     are not meaningful.

     The high resolution file time stamps of many modern hosts lessen
     the chance of `make' incorrectly concluding that a file is up to
     date.  Unfortunately, these hosts provide no way to set a high
     resolution file time stamp, so commands like `cp -p' that
     explicitly set a file's time stamp must discard its subsecond
     part.  If a file is created by such a command, you should list it
     as a prerequisite of `.LOW_RESOLUTION_TIME' so that `make' does
     not mistakenly conclude that the file is out of date.  For example:

          .LOW_RESOLUTION_TIME: dst
          dst: src
                  cp -p src dst

     Since `cp -p' discards the subsecond part of `src''s time stamp,
     `dst' is typically slightly older than `src' even when it is up to
     date.  The `.LOW_RESOLUTION_TIME' line causes `make' to consider
     `dst' to be up to date if its time stamp is at the start of the
     same second that `src''s time stamp is in.

     Due to a limitation of the archive format, archive member time
     stamps are always low resolution.  You need not list archive
     members as prerequisites of `.LOW_RESOLUTION_TIME', as `make' does
     this automatically.

`.SILENT'
     If you specify prerequisites for `.SILENT', then `make' will not
     print the commands to remake those particular files before
     executing them.  The commands for `.SILENT' are not meaningful.

     If mentioned as a target with no prerequisites, `.SILENT' says not
     to print any commands before executing them.  This usage of
     `.SILENT' is supported only for historical compatibility.  We
     recommend you use the more selective ways to silence specific
     commands.  *Note Command Echoing: Echoing.  If you want to silence
     all commands for a particular run of `make', use the `-s' or
     `--silent' option (*note Options Summary::).

`.EXPORT_ALL_VARIABLES'
     Simply by being mentioned as a target, this tells `make' to export
     all variables to child processes by default.  *Note Communicating
     Variables to a Sub-`make': Variables/Recursion.

`.NOTPARALLEL'
     If `.NOTPARALLEL' is mentioned as a target, then this invocation of
     `make' will be run serially, even if the `-j' option is given.
     Any recursively invoked `make' command will still be run in
     parallel (unless its makefile contains this target).  Any
     prerequisites on this target are ignored.

   Any defined implicit rule suffix also counts as a special target if
it appears as a target, and so does the concatenation of two suffixes,
such as `.c.o'.  These targets are suffix rules, an obsolete way of
defining implicit rules (but a way still widely used).  In principle,
any target name could be special in this way if you break it in two and
add both pieces to the suffix list.  In practice, suffixes normally
begin with `.', so these special target names also begin with `.'.
*Note Old-Fashioned Suffix Rules: Suffix Rules.

